============
    介绍
============

`查看幻灯片 <intro-slides.html>`_

.. slideconf::
   :autoslides: False
   :theme: single-level

课程目标:
===================

.. slide:: Introduction
   :inline-contents: True
   :level: 2

   * 基本的操作系统名词和概念

   * Linux 内核概述


基本的操作系统名词和概念
==========================================

用户与内核的比较
--------------

.. slide:: 用户与内核的比较
   :level: 2

   * 执行模式

     * 内核模式

     * 用户模式

   * 内存保护

     * 内核空间

     * 用户空间


内核（kernel）和用户（user）是操作系统中经常使用的两个术语。它们的定义非常直接：内核是以较高权限级别运行的操作系统部分，而用户（空间）通常指以较低权限级别运行的应用程序。

然而，这些术语在不同的上下文中可能有非常特定的含义，因此它们被赋予了多种不同的解释。

用户模式（user mode）和内核模式（kernel mode）是可能特指处理器执行模式的术语。在内核模式下运行的代码可以完全 [#hypervisor]_ 控制 CPU，而在用户模式下运行的代码有一定的限制。例如，在内核模式下运行时可以启用或禁用本地 CPU 中断，而在用户模式下尝试执行此类操作将产生异常并由内核接管处理。

.. [#hypervisor] 有些处理器可能具有比内核模式更高的特权，例如，虚拟机监视器（hypervisor）模式，仅允许在虚拟机监视器（虚拟机监控程序）中运行的代码访问。

用户空间（user space）和内核空间（kernel space）可以特指内存保护或与内核或用户应用程序关联的虚拟地址空间。

你可以粗略地理解为，内核空间是保留给内核的内存区域，而用户空间是保留给特定用户进程的内存区域。内核空间被保护访问，因此用户应用程序无法直接访问它，而用户空间可以被在内核模式下运行的代码直接访问。


典型的操作系统架构
-------------------------------------

在典型的操作系统架构中（如下图所示），操作系统内核负责以安全和公平的方式让多个应用程序访问和共享硬件资源。

.. slide:: 典型操作系统架构

   :level: 2
   :inline-contents: True

   .. code-block:: text

      +---------------+  +--------------+      +---------------+  -\
      |   应用程序 1   |  |   应用程序 2  | ...  |   应用程序 n  |   |
      +---------------+  +--------------+      +---------------+   |> 用户空间
              |                 |                      |           |
              v                 v                      v          -/
      +--------------------------------------------------------+  -\
      |                     系统调用接口                        |   |
      +--------------------------------------------------------+   |
              |                 |                      |           |
              v                 v                      v           |> 内核空间
      +--------------------------------------------------------+   |
      |                        内核                            |   |
      +--------------------------------------------------------+   |
      |                      设备驱动                           |   |
      +--------------------------------------------------------+  -/
              |                 |                      |          -\
              v                 v                      v           |> 硬件
                                                                  -/



内核提供了一组用来给应用程序调用的 API，通常称为“系统调用”。这些 API 与常规的库 API 不同，因为它们是执行模式从用户模式切换到内核模式的边界。

为了提供应用程序的兼容性，系统调用很少发生变化。Linux 特别强制执行此规定（与可能根据需要更改的内核 API 相对）。

内核代码本身可以在逻辑上分为核心内核代码和设备驱动程序代码。设备驱动程序代码负责访问特定设备，而核心内核代码是通用的。核心内核还可以进一步划分为多个逻辑子系统（例如文件访问、网络还有进程管理等）。


单体内核
-----------------

单体内核（monolithic kernel，又译宏内核或巨内核）是指没有对各个内核子系统之间的访问进行保护的内核，其中公共函数可以在各个子系统之间直接调用。


.. slide:: 单体内核
   :level: 2
   :inline-contents: True

   .. code-block:: text

      +-----+          +-----+          +-----+
      | 应用 |         | 应用 |          | 应用 |
      +-----+          +-----+          +-----+
         |                |                |                用户 
      =--|-------=--------|--------=-------|-------------------=-
         |                |                |                内核
         v                v                v
      +--------------------------------------------------------+
      |                   系统调用接口                          |
      +--------------------------------------------------------+
                |                                    |
                v                                    v
             +-----+                              +-----+
             |     |<---------------------------->|     |  内核  
             |     |<---+                +------->|     |  函数 
             +--+--+    |                |        +-----+
                |       |                |           ^
                |       |     +-----+    |           |
                |+------+---->|     |<---+           |
                ||      |     +-----+                |
                ||      |                            |
                vv      |                            v
             +--++-+    |                         +-----+
             |     |    +------------------------>|     |  设备
             |     |<---------------------------->|     |  驱动
             +--+--+                              +--+--+
                |                                    |
                v                                    v
      +--------------------------------------------------------+
      |                           硬件                         |
      +--------------------------------------------------------+


然而，大多数单体内核确实在子系统之间实施了逻辑分离，特别是在核心内核和设备驱动程序之间，需要通过相对严格的 API（但不一定是固定不变的）来访问一个子系统或设备驱动程序提供的服务。当然，这取决于特定的内核实现和内核的架构。


微内核
------------

微内核（micro kernel）是指内核的大部分功能彼此之间的访问都受到保护，通常作为用户空间中的服务运行。由于内核的重要功能现在运行在用户模式下，运行在内核模式下的剩余代码显著减少，因此称为微内核。

   .. code-block:: text

        +-----+   +--------+  +---------+ +---------+
        | 应用 |  |  文件   |  |   网络  | |   显示  |<--+
        | 服务 |  |  服务器 |  |  服务器 | |  服务器  |-+ |
        +-----+   +--------+  +---------+ +---------+ | |
         | ^                                          | |     用户
        -|-|----------------------------------------=-|-|-------=-
         | |                                          | |     内核
         | |                                          | |
         | |                                          | |
         | |                                          | |
         | |  回复  +----------------------------+    | |
         | +--------|                            |----+ |
         +--------->|            微内核           |------+
             请求   | （进程间通信（IPC），内存，   |
                    |            调度程序）       |
                    +----------------------------+
                                 |
                                 v
        +--------------------------------------------------------+
        |                       硬件                             |
        +--------------------------------------------------------+


在微内核架构中，内核仅包含足够允许不同的运行中的进程间进行消息传递的代码。实践中，这意味着在内核中实现调度程序和进程间通讯（IPC）机制，以及基本的内存管理以建立应用程序和服务之间的保护。

这种架构的优点之一是服务被隔离，因此某一个服务中的错误不会影响其他服务。

因此，如果一个服务崩溃，我们可以只重启它而不影响整个系统。然而，实践中很难实现这一点，因为重新启动一个服务可能会影响依赖该服务的所有应用程序（例如，如果文件服务器崩溃，所有打开文件描述符的应用程序在访问文件时会遇到错误）。

这种架构对内核施加了模块化的方法，并在服务之间提供了内存保护，但代价是性能。在单体内核上两个服务之间的简单函数调用现在需要通过 IPC 和调度，这将导致性能损失 [#minix-vs-linux]_。

.. [#minix-vs-linux] https://lwn.net/Articles/220255/


微内核与单体内核的比较
-----------------

微内核的支持者经常认为微内核由于其强制性的模块化设计而更优越。然而，单体内核也可以是模块化的，现代单体内核采用了以下几种方法来实现这一目标：

.. slide:: 单体内核*可以*是模块化的
   :level: 2
   :inline-contents: True

   * 组件可以在编译时启用或禁用

   * 支持可加载的内核模块（在运行时）

   * 将内核组织成逻辑上独立的子系统

   * 严格的接口，但其性能开销低：宏、内联函数以及函数指针


有一类操作系统（曾经）声称自己是混合内核，介于单体内核和微内核之间（例如 Windows 以及 Mac OS X）。但是，由于这些操作系统中所有典型的单体服务都在内核模式下运行，因此几乎没有理由将它们称为其他类型的内核，而不是单体内核。

.. slide:: “混合”内核
   :level: 2
   :inline-contents: True

   许多操作系统和内核专家认为这个标签毫无意义，只是营销手段。Linus Torvalds 对此问题说：

   “至于所谓的‘混合内核’，那只是营销而已。‘哦，那些微内核有很好的公关，我们怎么能给我们的工作内核也弄点好公关呢？哦，我知道了，让我们用一个酷酷的名字，来暗示它具有其他系统所拥有的所有公关优势’。”


地址空间
-----------

.. slide:: 地址空间
   :level: 2

   * 物理地址空间

    * RAM和外设内存

   * 虚拟地址空间

     * CPU 在受保护/分页模式下看到的内存

     * 进程地址空间

     * 内核地址空间


地址空间这个术语在不同的上下文中有不同的含义。

物理地址空间指的是 RAM 和设备内存在内存总线上的可见方式。例如，在 32 位 Intel 架构上，通常将 RAM 映射到较低的物理地址空间，而将显卡内存映射到较高的物理地址空间。

虚拟地址空间（有时只称为地址空间）指的是当虚拟内存模块启用时，CPU 看到内存的方式（有时称为保护模式或启用分页）。内核负责设置映射，创建虚拟地址空间，其中该空间的某些区域（area）映射到特定的物理内存区域。

与虚拟地址空间相关的还有另外两个常用的术语：进程（地址）空间和内核（地址）空间。

进程空间是与进程相关联的（部分）虚拟地址空间。它是进程的“内存视图”。它是一个从零开始的连续区域。进程的地址空间的结束位置取决于具体的实现和架构。

内核空间是以内核模式运行的代码的“内存视图”。


用户和内核共享虚拟地址空间
-------------------------

一种典型的用户和内核空间的实现方式是将虚拟地址空间在用户进程和内核之间共享。

在这种情况下，内核空间位于地址空间的顶部，而用户空间位于底部。为了防止用户进程访问内核空间，内核创建了映射，阻止用户模式下对内核空间的访问。

.. slide:: 用户和内核共享虚拟地址空间

   :level: 2
   :inline-contents: True

   .. code-block:: text

                  +-------------------+  ^
      0xFFFFFFFF  |                   |  |
                  |                   |  | 内核空间
                  |                   |  |
                  +-------------------+  v
      0xC0000000  |                   |  ^
                  |                   |  | 用户空间
                  |                   |  |
                  |                   |  |
                  |                   |  |
                  |                   |  |
                  |                   |  |
                  |                   |  |
                  |                   |  |
      0x00000000  +-------------------+  v

                   32 位虚拟地址空间

执行上下文
------------------

.. slide:: 执行上下文
   :level: 2

   * 进程上下文

     * 在用户模式下运行的代码，属于进程的一部分

     * 作为进程发出的系统调用的结果，在内核模式下运行的代码

   * 中断上下文：

     * 作为中断的结果而运行的代码

     * 总是在内核模式下运行


内核最重要的工作之一是有效地处理中断。这一点非常重要，以至于与之相关联了一个特殊的执行上下文。

当内核由于中断而运行时，它会在中断上下文中执行。这包括中断处理程序，但不仅限于此，还有其他一些特殊的（软件）结构也会在中断模式下运行。

在中断上下文中运行的代码始终在内核模式下运行，内核程序员必须注意一些限制（例如不能调用阻塞函数（blocking function）或访问用户空间）。

与中断上下文相对的是进程上下文。在进程上下文中的代码既可以在用户模式（执行应用程序代码）也可以在内核模式（执行系统调用）运行。


多任务处理
-------------

.. slide:: 多任务处理
   :level: 2

   * 支持“同时”执行多个进程的操作系统

   * 通过快速切换运行进程来实现，以允许用户与每个程序进行交互

   * 实现方式：

     * 合作式

     * 抢占式

多任务处理是操作系统同时执行多个程序的能力。它通过快速在运行进程之间切换来实现。

合作式（cooperative）多任务处理要求程序协作以实现多任务处理。一个程序运行之后会将 CPU 控制权交还给操作系统，然后操作系统会调度另一个程序运行。

在抢占式（preemptive）多任务处理中，内核会对每个进程强制执行严格的限制，以使所有进程都有公平的运行机会。每个进程被允许运行一个时间片段（slice）（例如 100 毫秒），之后如果它仍在运行，则会被强制抢占并调度另一个任务。


抢占式内核
-----------------

.. slide:: 抢占式内核
   :level: 2
   :inline-contents: True

   抢占式多任务处理和抢占式内核是不同的术语。

   如果一个进程在内核模式下运行时可以被抢占，则内核是抢占式的。

   然而，请注意非抢占式内核可能支持抢占式多任务处理。


可分页的内核内存
----------------------

.. slide:: 可分页的内核内存
   :level: 2
   :inline-contents: True

   如果内核内存的某些部分（代码、数据、堆栈或动态分配内存）可以交换到磁盘上，则内核支持可分页的内核内存。

内核堆栈
------------

.. slide:: 内核堆栈
   :level: 2
   :inline-contents: True

   每个进程都有一个内核堆栈，用于在执行系统调用时，保持函数调用链和局部变量状态。内核栈在进程处于内核模式时使用。

   内核堆栈很小（4 KB - 12 KB），因此内核开发人员必须避免在堆栈上分配大型结构或未适当限定的递归调用。

可移植性
-----------

为了增加在各种架构（architecture）和硬件配置之间的可移植性，现代内核在顶层上组织如下：

.. slide:: 可移植性
   :level: 2
   :inline-contents: True

   * 架构和机器特定代码（C 和 汇编）

   * 独立于架构的代码（C）：

     * 内核核心（进一步分为多个子系统）

     * 设备驱动程序

这使得在不同架构和机器配置之间尽可能地重用代码更容易。


非对称多处理（ASMP）
---------------------------------

非对称多处理（Asymmetric MultiProcessing，ASMP）是一种通过内核支持多个处理器（核心）的方式。其中一个处理器专门用于内核，而其他处理器则用于运行用户空间程序。

这种方法的缺点是内核吞吐量（例如系统调用、中断处理等）不随处理器数量的增加而扩展，然而典型的进程经常使用系统调用。该方法的可扩展性仅限于非常特定的系统（例如科学应用）。


.. slide:: 非对称多处理（ASMP）
   :level: 2
   :inline-contents: True

   .. code-block:: text

                                  +-----------+
                                  |           |
              +------------------>|   内存    |<-----------------+
              |                   |           |                  |
              |                   +-----------+                  |
              |                         ^                        |
              |                         |                        |
              v                         v                        v
      +--------------+          +---------------+         +---------------+
      |              |          |               |         |               |
      |   处理器 A    |          |  处理器 B     |         |  处理器 C     |
      |              |          |               |         |               |
      |              |          | +-----------+ |         | +-----------+ |
      |              |          | | 进程 1    | |         | | 进程 1    | |
      |              |          | +-----------+ |         | +-----------+ |
      |              |          |               |         |               |
      | +----------+ |          | +-----------+ |         | +-----------+ |
      | |  内核    | |          | | 进程 2    | |         | | 进程 2    | |
      | +----------+ |          | +-----------+ |         | +-----------+ |
      |              |          |               |         |               |
      |              |          | +-----------+ |         | +-----------+ |
      |              |          | | 进程 3    | |         | | 进程 3    | |
      |              |          | +-----------+ |         | +-----------+ |
      +--------------+          +---------------+         +---------------+


对称多处理（Symmetric MultiProcessing，SMP）
-------------------------------

与 ASMP 相反，在 SMP 模式下，内核可以在任何现有处理器上运行，就像用户进程一样。这种方法更难实现，因为如果两个进程运行访问相同内存位置的内核函数，会在内核中产生竞态条件（race condition）。

为了支持 SMP，内核必须实现同步原语（synchronization primitive）（例如自旋锁（spin lock））来保证只有一个处理器执行临界区（critical section）。

.. slide:: 对称多处理（SMP）
   :level: 2
   :inline-contents: True

   .. code-block:: text

                                   +-----------+
                                   |           |
              +------------------->|   内存    |<------------------+
              |                    |           |                   |
              |                    +-----------+                   |
              |                          ^                         |
              |                          |                         |
              v                          v                         v
      +---------------+          +---------------+         +---------------+
      |               |          |               |         |               |
      |  处理器 A      |          |  处理器 B      |         |  处理器 C     |
      |               |          |               |         |               |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      | | 进程 1    | |          | | 进程 1    | |          | | 进程 1    | |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      |               |          |               |         |               |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      | | 进程 2    | |          | | 进程 2     | |         | | 进程 2    | |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      |               |          |               |         |               |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      | |   内核    | |          | |   内核    | |          | |   内核    | |
      | +-----------+ |          | +-----------+ |         | +-----------+ |
      +---------------+          +---------------+         +---------------+


CPU可扩展性
---------------

CPU 可扩展性是指随着核心（core）数量的增加，性能可以扩展到什么程度。内核开发者应该关注以下几点以提高 CPU 的可扩展性：

.. slide:: CPU 可扩展性
   :level: 2
   :inline-contents: True

   * 尽可能使用无锁（lock free）算法

   * 对于高争用区域（high contention areas）使用细粒度锁（fine grained locking）

   * 注意算法复杂度


Linux内核概述
============================


Linux开发模型
-----------------------

.. slide:: Linux开发模型
   :level: 2

   * 开源，采用 GPLv2 许可证

   * 贡献者：公司、学术界和独立开发者

   * 开发周期：3 - 4 个月，包括 1 - 2 周的合并窗口（merge window）和错误修复阶段

   * 新功能只允许在合并窗口期间合并

   * 合并窗口结束后,每周会制作一个发行候选（release candidate）版本（rc1、rc2等）

Linux 内核是世界上最大的开源项目之一，拥有成千上万的开发人员贡献代码，每个发布版本都会有数百万行的代码更改。

它采用 GPLv2 许可证进行分发，简而言之，要求在交付给客户的软件上对内核所做的任何修改都应提供给客户，但实际上大多数公司都会公开源代码。

许多公司（通常是竞争对手）以及学术界还有独立开发者向 Linux 内核贡献代码。

目前的开发模型是基于固定时间间隔进行发布（通常为 3 - 4 个月）。新功能在一两周的合并窗口期间合并到内核中。合并窗口结束后，每周发布一个发行候选版本（rc1、rc2 等）。


维护者层次结构
--------------------

为了优化开发流程，Linux 使用了一个层次化的维护模型：

.. slide:: 维护者层次结构
   :level: 2
   :inline-contents: True

   * Linus Torvalds 是 Linux 内核的维护者，他从子系统维护者那里合并拉取请求（pull request）

   * 每个子系统都有一个或多个维护者，他们接受开发者或设备驱动程序维护者的补丁或拉取请求

   * 每个维护者都有自己的 git 树，例如：

     * Linux Torvalds: git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

     * David Miller（网络）：git://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/

   * 每个子系统可能维护一个 -next 树，开发者可以在其中提交下一个合并窗口的补丁（patch）

由于合并窗口最多只有两周时间，大多数维护者都拥有一个 -next 树，这样即使合并窗口关闭，他们也能接受下游开发者或维护者的新功能。

请注意，错误修复（bug fix）即使是在合并窗口外也可以被维护者的树接受，并定期由上游维护者拉取，用于每个发行候选版本。



Linux 源代码布局
-------------------------

.. slide:: Linux 源代码布局
   :level: 2
   :inline-contents: True

   .. code-block:: text

      +-------+
      | linux |
      +-+-----+
        |
        +------+--------+---------+---------+--------------+--------------+
        |      |        |         |         |              |              |
        |      v        v         v         v              v              v
        |  +------+ +-------+ +-------+ +--------+ +---------------+ +---------+
        |  | arch | | block | | certs | | crypto | | Documentation | | drivers |
        |  +------+ +-------+ +-------+ +--------+ +---------------+ +---------+
        |
        +-------+----------+--------+---------+--------+--------+---------+
        |       |          |        |         |        |        |         |
        |       v          v        v         v        v        v         v
        |  +----------+ +----+ +---------+ +------+ +-----+ +--------+ +-----+
        |  | firmware | | fs | | include | | init | | ipc | | kernel | | lib |
        |  +----------+ +----+ +---------+ +------+ +-----+ +--------+ +-----+
        |
        +-----+------+---------+------------+------------+------------+
        |     |      |         |            |            |            |
        |     v      v         v            v            v            v
        |  +----+ +-----+ +---------+ +---------+  +----------+ +-------+
        |  | mm | | net | | samples | | scripts |  | security | | sound |
        |  +----+ +-----+ +---------+ +---------+  +----------+ +-------+
        |
        +------+--------+--------+
               |        |        |
               v        v        v
           +-------+ +-----+ +------+
           | tools | | usr | | virt |
           +-------+ +-----+ +------+


以下是 Linux 源代码文件夹的顶层目录：

* arch——包含特定架构（architecture）的代码；每个架构在特定的子文件夹中实现（例如 arm、arm64 以及 x86）

* block——包含与读写块设备数据相关的块子系统代码：创建块 I/O 请求、调度（scheduling）请求（有几个 I/O 调度程序可用）、合并请求，并将其通过 I/O 堆栈传递给块设备驱动程序

* certs——使用证书实现签名检查支持

* crypto——各种加密算法的软件实现，以及允许将这些算法分载到硬件中的框架

* Documentation——各个子系统的文档、对 Linux 内核命令行选项的描述、对 sysfs 文件和格式的描述以及设备树绑定（支持的设备树节点和格式）

* drivers——各种设备的驱动程序以及 Linux 驱动程序模型实现（对驱动程序、设备总线及其连接方式的抽象描述）

* firmware——由各种设备驱动程序使用的二进制或十六进制固件文件

* fs——虚拟文件系统切换（通用文件系统代码）以及各种文件系统驱动程序的位置

* include——头文件

* init——在启动过程中运行的通用（而不是特定于架构的）初始化代码

* ipc——对各种进程间通信系统（Inter Process Communication）调用的实现，例如消息队列、信号量、共享内存

* kernel——进程管理代码（包括对内核线程、工作队列的支持）、调度程序（scheduler）、跟踪、时间管理、通用中断代码（generic irq code）以及锁定（locking）

* lib——各种通用函数，例如排序、校验和、压缩和解压缩、位图操作等

* mm——内存管理代码，用于物理和虚拟内存，包括页面、SL*B 和 CMA 分配器、交换（swapping）、虚拟内存映射、进程地址空间操作等

* net——各种网络协议栈的实现，包括IPv4和IPv6；BSD 套接字实现、路由、过滤、数据包调度以及桥接（bridging）等

* samples——各种驱动程序示例

* scripts——构建系统的一部分，用于构建模块的脚本，Linux 内核配置器 kconfig，以及其他各种脚本（例如 checkpatch.pl，用于检查补丁（patch）是否符合 Linux 内核的编码风格）

* security——Linux 安全模块框架的位置，允许扩展默认（Unix）安全模型，以及多个此类扩展的实现，例如 SELinux、smack、apparmor 以及 tomoyo 等

* sound——ALSA（Advanced Linux Sound System，高级 Linux 声音系统）的位置，以及旧的 Linux 音频框架（OSS）

* tools——用于测试或与 Linux 内核子系统交互的各种用户空间工具

* usr——支持在内核映像中嵌入 initrd 文件

* virt——KVM（Kernel Virtual Machine，内核虚拟机）虚拟化管理程序（hypervisor）的位置


Linux 内核结构
-------------------------

.. slide:: Linux 内核结构
   :level: 2
   :inline-contents: True

   .. code-block:: text

      +---------------+  +--------------+      +---------------+
      | 应用程序 1    |   | 应用程序 2   | ...  |   应用程序 n   |
      +---------------+  +--------------+      +---------------+
              |                 |                      |
              v                 v                      v
      +--------------------------------------------------------+
      |                       内核                             |
      |                                                        |
      |   +----------------------+     +-------------------+   |
      |   |     进程管理         |      |      内存管理      |   |
      |   +----------------------+     +-------------------+   |
      |                                                        |
      |   +------------+    +------------+    +------------+   |
      |   | Block I/O  |    |    VFS     |    | Networking |   |
      |   +------------+    +------------+    +------------+   |
      |                                                        |
      |   +------------+    +------------+    +------------+   |
      |   |    IPC     |    |  Security  |    |   Crypto   |   |
      |   +------------+    +------------+    +------------+   |
      |                                                        |
      |   +------------+    +------------+    +------------+   |
      |   |    DRM     |    |    ALSA    |    |    USB     |   |
      |   +------------+    +------------+    +------------+   |
      |                        ...                             |
      +--------------------------------------+-----------------+
      |              设备驱动程序             |      arch       |
      |                                      |                 |
      | +----+  +-----+  +--------+ +----+   |  +----------+   |
      | |字符 | |块设备 | |以太网  | |wifi |   | |   机器 1   |  |
      | +----+  +-----+  +--------+ +----+   |  +----------+   |
      | +--------+ +-----+   +----+ +---+    |  +----------+   |
      | |文件系统| |输入设备| |IIO | |USB |    | |  机器 2   |   |
      | +--------+ +-----+   +----+ +---+    |  +----------+   |
      | +-----------+ +----------+  +---+    |                 |
      | |帧缓冲区    | |平台设备  |  |DRM |   |     ...         |
      | +-----------+ +----------+  +---+    |                 |
      +-------------------------+----+-------+-----------------+
              |                 |                      |
              v                 v                      v

      +--------------------------------------------------------+
      |                         硬件                           |
      +--------------------------------------------------------+


arch
....

.. slide:: arch
   :level: 2
   :inline-contents: True

   * 针对架构的特定代码

   * 可能进一步细分为针对机器的特定代码

   * 与引导加载程序（boot loader）以及特定于架构的初始化程序进行交互

   * 访问各种硬件位，这些硬件位是架构或机器特定的，例如中断控制器、SMP 控制器、总线控制器、异常和中断设置以及虚拟内存处理

   * 针对架构优化的函数（例如 memcpy，字符串操作等）

这部分是关于 Linux 内核的架构特定代码，可能会进一步细分为特定架构的特定机器的代码（例如 arm）。

“Linux最初是为 32 位基于 x86 的个人电脑（386 或更高版本）开发的。如今，它也可以（至少）运行在 Compaq Alpha AXP、Sun SPARC 和 UltraSPARC、Motorola 68000、PowerPC、PowerPC64、ARM、Hitachi SuperH、IBM S/390、MIPS、HP PA-RISC、Intel IA-64、DEC VAX、AMD x86-64 和 CRIS 等架构上。”

它实现了对各种硬件位的访问，这些硬件位是架构或机器特定的，例如中断控制器、SMP 控制器、总线控制器、异常和中断设置以及虚拟内存处理。

它还实现了针对架构优化的函数（例如 memcpy，字符串操作等）。


设备驱动程序
...........

.. slide:: 设备驱动程序
   :level: 2

   * 统一的设备模型

   * 每个子系统都有自己特定的驱动程序接口

   * 许多设备驱动程序类型（TTY、串行设备、SCSI、文件系统、以太网、USB 设备、帧缓冲区、输入设备以及声音设备等）

Linux 内核使用统一的设备模型，其目的是维护反映系统状态和结构的内部数据结构。这些信息包括哪些设备存在、它们的状态如何、它们连接到哪个总线以及它们连接到哪个驱动程序等。这些信息对于实现系统范围的电源管理，以及设备发现和动态设备移除至关重要。

每个子系统都有自己特定的驱动程序接口，该接口针对其所表示的设备进行了定制，以便更容易编写正确的驱动程序并减少代码重复。

Linux 支持最多样化的设备驱动程序类型，例如 TTY、串行设备、SCSI、文件系统、以太网、USB 设备、帧缓冲区、输入设备以及声音设备等


进程管理
..................

.. slide:: 进程管理
   :level: 2

   * Unix 基本进程管理和 POSIX 线程支持

   * 进程和线程被抽象为任务

   * 操作系统级虚拟化

     *  命名空间（namespace）

     * 控制组


Linux 实现了标准的 Unix 进程管理 API，如 fork()、exec()、wait()，以及标准的 POSIX 线程。

不过，Linux 中的进程和线程的实现方式与其他内核显著不同。Linux 并没有用内部结构来实现进程或线程，而是使用了一个名为 :c:type:`struct task_struct` 的结构体来描述被称为任务（task）的抽象调度单元。

每个任务具有指向资源的指针，例如地址空间、文件描述符、IPC id 等。属于同一进程的任务的资源指针指向相同的资源，而不同进程的任务的资源指针将指向不同的资源。

这种特点与 clone() 和 unshare() 系统调用一起，可以实现诸如命名空间等新特性。

命名空间与控制组（cgroup）一起用于在 Linux 中实现操作系统级别的虚拟化。

cgroup 是一种以层次结构组织进程并以受控且可配置的方式分配系统资源的机制。


内存管理
.................

Linux 内存管理是一个复杂的子系统，它负责处理：

.. slide:: 内存管理
   :level: 2
   :inline-contents: True

   * 物理内存的管理：分配和释放内存

   * 虚拟内存的管理：分页，交换，需求分页（demand paging），写时复制（copy on write）

   * 用户服务：用户地址空间管理（例如 mmap()，brk()，共享内存）

   * 内核服务：SL*B 分配器，vmalloc



块 I/O 管理
....................

Linux 块I/O 子系统处理读取和写入块设备数据的操作：创建块 I/O 请求、转换块 I/O 请求（例如用于软件 RAID 或 LVM）、合并和排序请求，并通过各种 I/O 调度程序将它们调度到块设备驱动程序。

.. slide:: 块I/O管理
   :level: 2
   :inline-contents: True

   .. code-block:: text

      +---------------------------------+
      |       虚拟文件系统切换           |
      +---------------------------------+
                     ^
                     |
                     v
      +---------------------------------+
      |         设备映射器               |
      +---------------------------------+
                     ^
                     |
                     v
      +---------------------------------+
      |           通用块层               |
      +---------------------------------+
                     ^
                     |
                     v
      +--------------------------------+
      |          I/O 调度程序           |
      +--------------------------------+
             ^                ^
             |                |
             v                v
      +--------------+  +--------------+
      |块设备驱动程序 |  | 块设备驱动程序 |
      +--------------+  +--------------+


虚拟文件系统切换
...............

Linux 虚拟文件系统切换（Virtual Filesystem Switch，VFS）实现了通用的文件系统代码，以减少文件系统驱动程序中的重复。它引入了一些文件系统抽象，例如：

* inode（index node，索引节点）——描述磁盘上的文件（属性，数据块在磁盘上的位置）

* dentry（directory entry，目录项）——将 inode 与名称链接起来

* file（文件）——描述打开文件的属性（例如文件指针）

* superblock（超级块）——描述格式化文件系统的属性（例如块数、块大小、根目录在磁盘上的位置、加密等）

.. slide:: 虚拟文件系统切换
   :level: 2
   :inline-contents: True

   .. code-block:: text


             ^                    ^                    ^
             | stat               | open               | read
             v                    v                    v
      +------------------------------------------------------------+
      |                   虚拟文件系统切换                          |
      |                                                            |
      |                                                            |
      |    /-------\           /--------\           /--------\     |
      |    | inode |<----------+ dentry |<----------+  FILE  |     |
      |    \---+---/           \----+---/           \---+----/     |
      |        |                    |                   |          |
      |        |                    |                   |          |
      |        v                    v                   v          |
      |    +-------+           +--------+           +-------+      |
      |    | inode |           | dentry |           | page  |      |
      |    | cache |           | cache  |           | cache |      |
      |    +-------+           +--------+           +-------+      |
      |                                                            |
      +------------------------------------------------------------+
                   ^                                  ^
                   |                                  |
                   v                                  v
            +-------------+                    +-------------+
            | 文件系统驱动 |                    | 文件系统驱动 |
            +-------------+                    +-------------+


Linux VFS 还实现了一个复杂的缓存机制，包括以下内容：

* inode 缓存——缓存文件属性和内部文件元数据

* dentry 缓存——缓存文件系统的目录层次结构

* page 缓存——在内存中缓存文件数据块



网络堆栈
................

.. slide:: 网络堆栈
   :level: 2
   :inline-contents: True

   .. code-block:: text

      +---------------------------+
      | 伯克利套接字（socket）接口  |
      +---------------------------+

      +---------------------------+
      | 传输层（Transport layer）  |
      +-------------+-------------+
      |      TCP    |     UDP     |
      +-------------+-------------+

      +---------------------------+
      |  网络层（Network layer）   |
      +-----+---------+-----------+
      | IP  | 路由    | NetFilter |
      +-----+---------+-----------+

      +---------------------------+
      |数据链路层（Data link layer）|
      +-------+-------+-----------+
      |  ETH  |  ARP  | BRIDGING  |
      +-------+-------+-----------+

    +--------------------------------+
    |           队列调度机制          |
    |   （Queuing discipline，qdisc） |
    +--------------------------------+

      +---------------------------+
      |     网络设备驱动程序        |
      +---------------------------+

Linux 安全模块
......................

.. slide:: Linux 安全模块
   :level: 2
   :inline-contents: True

   * 扩展默认的 Linux 安全模型的钩子

   * 被几个 Linux 安全扩展使用:

     * 安全增强型 Linux（Security Enhanced Linux，SELinux）

     * AppArmor

     * Tomoyo

     * Smack
